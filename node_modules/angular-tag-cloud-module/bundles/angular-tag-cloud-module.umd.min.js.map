{"version":3,"sources":["ng://angular-tag-cloud-module/src/app/tag-cloud-module/tag-cloud.component.ts","ng://angular-tag-cloud-module/src/app/tag-cloud-module/tag-cloud.module.ts"],"names":["TagCloudComponent","el","r2","this","width","height","overflow","strict","zoomOnHover","transitionTime","scale","delay","color","realignOnResize","randomizeAngle","clicked","EventEmitter","dataChanges","afterInit","afterChecked","_alreadyPlacedWords","prototype","onResize","event","_this","window","clearTimeout","_timeoutId","setTimeout","reDraw","ngOnChanges","changes","emit","data","nativeElement","innerHTML","_dataArr","currentValue","parentNode","offsetWidth","_options","step","aspectRatio","center","x","y","setStyle","drawWordCloud","console","error","ngAfterContentInit","ngAfterContentChecked","descriptiveEntry","entry","description","text","external","link","rotate","sort","a","b","localeCompare","weight","forEach","elem","index","drawWord","hitTest","currentEl","otherEl","i","length","overlapping","Math","abs","offsetLeft","offsetTop","offsetHeight","word","wordSpan","angle","random","radius","log","round","createElement","className","thatClicked","onclick","node","createText","transformString","wordLink","href","undefined","target","appendChild","onmouseover","onmouseout","removeStyle","left","top","wordStyle","style","position","tooltip","addClass","tooltipSpan","cos","sin","push","remove","Component","args","selector","template","ElementRef","Renderer2","Input","Output","HostListener","TagCloudModule","NgModule","declarations","exports","entryComponents"],"mappings":"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","sourcesContent":["import { Component,\n         OnChanges,\n         AfterContentInit,\n         AfterContentChecked,\n         Input,\n         Output,\n         EventEmitter,\n         ElementRef,\n         Renderer2,\n         SimpleChanges,\n         HostListener } from '@angular/core';\nimport { CloudData, CloudOptions, ZoomOnHoverOptions } from './tag-cloud.interfaces';\n\ninterface CloudOptionsInternal extends CloudOptions {\n  step: number;\n\n  /**\n   * setting the aspect ratio. This value is calculated by the given width and height\n   */\n  aspectRatio: number;\n  center: {\n    x: number;\n    y: number;\n  };\n}\n\n@Component({\n  selector: 'angular-tag-cloud, ng-tag-cloud, ngtc',\n  template: '',\n  styleUrls: ['./tag-cloud.component.css']\n})\nexport class TagCloudComponent implements OnChanges, AfterContentInit, AfterContentChecked {\n  @Input() data: CloudData[];\n  @Input() width? = 500;\n  @Input() height? = 300;\n  @Input() overflow? = true;\n  @Input() strict? = false;\n  @Input() zoomOnHover?: ZoomOnHoverOptions = { transitionTime: 0, scale: 1, delay: 0, color: null };\n  @Input() realignOnResize? = false;\n  @Input() randomizeAngle? = false;\n\n  @Output() clicked?: EventEmitter<CloudData> = new EventEmitter();\n  @Output() dataChanges?: EventEmitter<SimpleChanges> = new EventEmitter();\n  @Output() afterInit?: EventEmitter<void> = new EventEmitter();\n  @Output() afterChecked?: EventEmitter<void> = new EventEmitter();\n\n  private _dataArr: CloudData[];\n  private _alreadyPlacedWords: HTMLElement[] = [];\n\n  private _options: CloudOptionsInternal;\n  private _timeoutId;\n\n  constructor(\n    private el: ElementRef,\n    private r2: Renderer2\n  ) { }\n\n  @HostListener('window:resize', ['$event'])\n  onResize(event) {\n    window.clearTimeout(this._timeoutId);\n    this._timeoutId = window.setTimeout(() => {\n      if (this.realignOnResize) {\n        this.reDraw();\n      }\n    }, 200);\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    this.reDraw(changes);\n  }\n\n  reDraw(changes?: SimpleChanges) {\n    this.dataChanges.emit(changes);\n    this._alreadyPlacedWords = [];\n\n    // check if data is not null or empty\n    if (!this.data) {\n      console.error('angular-tag-cloud: No data passed. Please pass an Array of CloudData');\n      return;\n    }\n\n    // values changed, reset cloud\n    this.el.nativeElement.innerHTML = '';\n\n    // set value changes\n    if (changes && changes['data']) {\n      this._dataArr = changes['data'].currentValue;\n    }\n\n    let width = this.width;\n    if (this.el.nativeElement.parentNode.offsetWidth > 0\n      && width <= 1\n      && width > 0\n    ) {\n      width = this.el.nativeElement.parentNode.offsetWidth * width;\n    }\n\n    // set options\n    this._options = {\n      step: 2.0,\n      aspectRatio: (width / this.height),\n      width: width,\n      height: this.height,\n      center: {\n        x: (width / 2.0),\n        y: (this.height / 2.0)\n      },\n      overflow: this.overflow,\n      zoomOnHover: this.zoomOnHover\n    };\n\n    this.r2.setStyle(this.el.nativeElement, 'width', this._options.width + 'px');\n    this.r2.setStyle(this.el.nativeElement, 'height', this._options.height + 'px');\n    // draw the cloud\n    this.drawWordCloud();\n  }\n\n\n  ngAfterContentInit() {\n    this.afterInit.emit();\n  }\n\n  ngAfterContentChecked() {\n    this.afterChecked.emit();\n  }\n\n  // helper to generate a descriptive string for an entry to use when sorting alphabetically\n  descriptiveEntry(entry: CloudData): string {\n    let description = entry.text;\n    if (entry.color) {\n      description += '-' + entry.color;\n    }\n    if (entry.external) {\n      description += '-' + entry.external;\n    }\n    if (entry.link) {\n      description += '-' + entry.link;\n    }\n    if (entry.rotate) {\n      description += '-' + entry.rotate;\n    }\n    return description;\n  }\n\n  drawWordCloud () {\n    // Sort alphabetically to ensure that, all things being equal, words are placed uniformly\n    this._dataArr.sort( (a, b) => (this.descriptiveEntry(a)).localeCompare(this.descriptiveEntry(b)));\n    // Sort this._dataArr from the word with the highest weight to the one with the lowest\n    this._dataArr.sort((a, b) => b.weight - a.weight);\n    this._dataArr.forEach((elem, index) => {\n      this.drawWord(index, elem);\n    });\n  }\n\n  // Helper function to test if an element overlaps others\n  hitTest(currentEl: HTMLElement, otherEl: HTMLElement[]): boolean {\n    // Check elements for overlap one by one, stop and return false as soon as an overlap is found\n    for (let i = 0; i < otherEl.length; i++) {\n      if (this.overlapping(currentEl, otherEl[i])) { return true; }\n    }\n    return false;\n  }\n\n  // Pairwise overlap detection\n  overlapping(a: HTMLElement, b: HTMLElement): boolean {\n    return (Math.abs(2.0 * a.offsetLeft + a.offsetWidth  - 2.0 * b.offsetLeft - b.offsetWidth)  < a.offsetWidth  + b.offsetWidth &&\n            Math.abs(2.0 * a.offsetTop  + a.offsetHeight - 2.0 * b.offsetTop  - b.offsetHeight) < a.offsetHeight + b.offsetHeight)\n    ? true : false;\n  }\n\n  // Function to draw a word, by moving it in spiral until it finds a suitable empty place. This will be iterated on each word.\n  drawWord(index: number, word: CloudData) {\n    // Define the ID attribute of the span that will wrap the word\n    let angle = this.randomizeAngle ? 6.28 * Math.random() : 0,\n        radius = 0.0,\n        weight = 5,\n        wordSpan: HTMLElement;\n\n    // Check if min(weight) > max(weight) otherwise use default\n    if (this._dataArr[0].weight > this._dataArr[this._dataArr.length - 1].weight) {\n      // check if strict mode is active\n      if (!this.strict) { // Linearly map the original weight to a discrete scale from 1 to 10\n        weight = Math.round((word.weight - this._dataArr[this._dataArr.length - 1].weight) /\n                  (this._dataArr[0].weight - this._dataArr[this._dataArr.length - 1].weight) * 9.0) + 1;\n      } else { // use given value for weigth directly\n        // fallback to 10\n        if (word.weight > 10) {\n          weight = 10;\n          console.log(`[TagCloud strict] Weight property ${word.weight} > 10. Fallback to 10 as you are using strict mode`, word);\n        } else if (word.weight < 1) { // fallback to 1\n          weight = 1;\n          console.log(`[TagCloud strict] Given weight property ${word.weight} < 1. Fallback to 1 as you are using strict mode`, word);\n        } else if (word.weight % 1 !== 0) { // round if given value is not an integer\n          weight = Math.round(word.weight);\n          console.log(`[TagCloud strict] Given weight property ${word.weight} is not an integer. Rounded value to ${weight}`, word);\n        } else {\n          weight = word.weight;\n        }\n\n      }\n    }\n\n    // Create a new span and insert node.\n    wordSpan = this.r2.createElement('span');\n    wordSpan.className = 'w' + weight;\n\n    const thatClicked = this.clicked;\n    wordSpan.onclick = () => {\n      thatClicked.emit(word);\n    };\n\n    let node = this.r2.createText(word.text);\n\n    // set color\n    if (word.color) {\n      this.r2.setStyle(wordSpan, 'color', word.color);\n    }\n\n    let transformString = '';\n\n    // set color\n    if (word.rotate) {\n      transformString = `rotate(${word.rotate}deg)`;\n      this.r2.setStyle(wordSpan, 'transform', transformString);\n    }\n\n    // Append href if there's a link alongwith the tag\n    if (word.link) {\n      const wordLink = this.r2.createElement('a');\n      wordLink.href = word.link;\n\n      if (word.external !== undefined && word.external) {\n        wordLink.target = '_blank';\n      }\n\n      wordLink.appendChild(node);\n      node = wordLink;\n    }\n\n    // set zoomOption\n    if (this.zoomOnHover && this.zoomOnHover.scale !== 1) {\n      if (!this.zoomOnHover.transitionTime) { this.zoomOnHover.transitionTime = 0; }\n      if (!this.zoomOnHover.scale) { this.zoomOnHover.scale = 1; }\n\n      wordSpan.onmouseover = () => {\n        this.r2.setStyle(wordSpan, 'transition', `transform ${this.zoomOnHover.transitionTime}s`);\n        this.r2.setStyle(wordSpan, 'transform', `scale(${this.zoomOnHover.scale}) ${transformString}`);\n        this.r2.setStyle(wordSpan, 'transition-delay', `${this.zoomOnHover.delay}s`);\n        if (this.zoomOnHover.color) {\n          word.link\n            ? this.r2.setStyle(node, 'color', this.zoomOnHover.color)\n            : this.r2.setStyle(wordSpan, 'color', this.zoomOnHover.color);\n        }\n      };\n\n      wordSpan.onmouseout = () => {\n        this.r2.setStyle(wordSpan, 'transform', `scale(1) ${transformString}`);\n        word.link\n          ? this.r2.removeStyle(node, 'color')\n          : this.r2.removeStyle(wordSpan, 'color');\n      };\n    }\n\n    wordSpan.appendChild(node);\n    this.r2.appendChild(this.el.nativeElement, wordSpan);\n\n    const width = wordSpan.offsetWidth;\n    const height = wordSpan.offsetHeight;\n    let left = this._options.center.x;\n    let top = this._options.center.y;\n\n    // Save a reference to the style property, for better performance\n    const wordStyle = wordSpan.style;\n    wordStyle.position = 'absolute';\n\n    // place the first word\n    wordStyle.left = left + 'px';\n    wordStyle.top = top + 'px';\n\n    // add tooltip if provided\n    if (word.tooltip) {\n      this.r2.addClass(wordSpan, 'tooltip');\n      const tooltipSpan = this.r2.createElement('span');\n      tooltipSpan.className = 'tooltiptext';\n      const text = this.r2.createText(word.tooltip);\n      tooltipSpan.appendChild(text);\n      wordSpan.appendChild(tooltipSpan);\n    }\n\n    while (this.hitTest(wordSpan, this._alreadyPlacedWords)) {\n      radius += this._options.step;\n      angle += (index % 2 === 0 ? 1 : -1) * this._options.step;\n\n      left = this._options.center.x - (width / 2.0) + (radius * Math.cos(angle)) * this._options.aspectRatio;\n      top = this._options.center.y + radius * Math.sin(angle) - (height / 2.0);\n\n      wordStyle.left = left + 'px';\n      wordStyle.top = top + 'px';\n    }\n\n    // Don't render word if part of it would be outside the container\n    if (\n      !this._options.overflow &&\n      (left < 0 || top < 0 || (left + width) > this._options.width ||\n      (top + height) > this._options.height)\n    ) {\n      wordSpan.remove();\n      return;\n    }\n\n    this._alreadyPlacedWords.push(wordSpan);\n  }\n\n}\n","import { NgModule } from '@angular/core';\nimport { TagCloudComponent } from './tag-cloud.component';\n\n@NgModule({\n  declarations: [TagCloudComponent],\n  exports: [TagCloudComponent],\n  entryComponents: [TagCloudComponent]\n})\nexport class TagCloudModule { }\n"]}